package com.jpa.demo.entity;

import java.util.List;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Table;

//entities are pojo classes means all fields are private and public getters and setters.
//not gonna use implements ,extends keyword here --so it's plain old java project.
@Entity
//if this annotation will not used...then hibernate won't persist Employee objects into database.
@Table(name = "employee")    //we are use this name for table
//Table annotation not mandatory ---automatically tablename of class with lowercase will be assigned.
public class Employee {
	
//	fields 
	@Id
	@GeneratedValue
	private int empId;
	@Column(name = "emp_name")
	private String empName;
	@Column(name = "emp_salary")
	private double Salary;
	
//	Create reference to implement Has-a-relationship----Unidirectional we are doing for now.
	@OneToOne(cascade = CascadeType.ALL)
	@JoinColumn(name="emp_login_fk")
	private Login login;
	
//	OneToMany
	@OneToMany(cascade = CascadeType.ALL)
	@JoinColumn(name="emp_addr_fk")
	private List<Address> address;
	
//	ManyToMany
	@ManyToMany(cascade = {CascadeType.PERSIST,CascadeType.MERGE,CascadeType.REFRESH})
	@JoinTable(
	     name = "employee_skills",
	     joinColumns = {@JoinColumn(name = "empid") },
	     inverseJoinColumns = {@JoinColumn(name = "skill_id") }
	) //WITHIN JOINTABLE ANNOTATION
	
	private List<Skill> skill;
	
//	constructors
	public Employee() {}    //before parameterized constructor default or no-arg constructor needs to be define.
	
	public Employee(String empName, double salary) {
		super();
		this.empName = empName;
		this.Salary = salary;
	}
	
//	Creating one more constructor for LOGIN entity purpose.---->no need to take id as it's auto-generated by @GeneratedValue annotation.
	public Employee(String empName, double salary, Login login) {
		super();
		this.empName = empName;
		Salary = salary;
		this.login = login;
	}
	
//	Adding one more constructor that will take address also as an argument(OneToMany) 
	public Employee(String empName, double salary, Login login, List<Address> address) {
		super();
		this.empName = empName;
		Salary = salary;
		this.login = login;
		this.address = address;
	}
	
	public Employee(int empId, String empName, double salary) {
		super();
		this.empId = empId;
		this.empName = empName;
		this.Salary = salary;
	}

//	Getters and Setters
	public int getEmpId() {
		return empId;
	}
	public void setEmpId(int empId) {
		this.empId = empId;
	}
	public String getEmpName() {
		return empName;
	}
	public void setEmpName(String empName) {
		this.empName = empName;
	}
	public double getSalary() {
		return Salary;
	}
	public void setSalary(double salary) {
		this.Salary = salary;
	}
	
//	Creating Getters & Setters for Login
	public Login getLogin() {
		return login;
	}

	public void setLogin(Login login) {
		this.login = login;
	}
	
//	Creating getters & setters for address
	public List<Address> getAddress() {
		return address;
	}

	public void setAddress(List<Address> address) {
		this.address = address;
	}
	
//	Generate Getters and Setters for skill
	public List<Skill> getSkill() {
		return skill;
	}

	public void setSkill(List<Skill> skill) {
		this.skill = skill;
	}

	
//	toString() method
//	@Override
//	public String toString() {
//		return "Employee [empId=" + empId + ", empName=" + empName + ", Salary=" + Salary + "]";
//	}
	
//	After adding new property better to update toString() method (HERE AFTER LOGIN ADDITION)
//	@Override
//	public String toString() {
//		return "Employee [empId=" + empId + ", empName=" + empName + ", Salary=" + Salary + ", login=" + login + "]";
//	}

	//	After adding new property better to update toString() method (HERE AFTER ADDRESS ADDITION)
//	whatever wanna print --add
//	@Override
//	public String toString() {
//		return "Employee [empId=" + empId + ", empName=" + empName + ", Salary=" + Salary + ", login=" + login
//				+ ", address=" + address + "]";
//	}
	
	@Override
	public String toString() {
		return "Employee [empId=" + empId + ", empName=" + empName + ", Salary=" + Salary + ", login=" + login
				+ ", address=" + address + ", skill=" + skill + "]";
	}
	
}
